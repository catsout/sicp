#!/bin/scheme --script

(define (entry tree) (car tree))
(define (left-branch tree) (cadr tree))
(define (right-branch tree) (caddr tree))
(define (make-tree entry left right)
  (list entry left right))
(define (element-of-set? x set)
  (cond ((null? set) #f)
		((= x (entry set)) #t)
		((< x (entry set)) (element-of-set? x (left-branch tree)))
		((> x (entry set)) (element-of-set? x (right-branch tree)))))
(define (tree->list-1 tree)
  (if (null? tree)
	'()
	(append (tree->list-1 (left-branch tree))
			(cons (entry tree) (tree->list-2 (right-branch tree))))))
(define (tree->list-2 tree)
  (define (copy-to-list tree set)
	(if (null? tree)
	  set
	  (copy-to-list (left-branch tree)
					(cons (entry tree) (copy-to-list (right-branch tree) set)))))
  (copy-to-list tree '()))

(define mytree (make-tree 100 
						  (make-tree 2
									 (make-tree 1 '() '())
									 (make-tree 3 '() '())) 
						  (make-tree 110
									 (make-tree 101 '() '())
									 (make-tree 111 '() '()))))

(define (list->tree set)
  (car (partial-tree set (length set))))
(define (partial-tree set n)
  (if (= n 0)
	(cons '() set)
	(let ((left-size (quotient (- n 1) 2)))
	  (let ((left-re (partial-tree set left-size))
			(right-size (- n (+ left-size 1))))
		(let ((left-tree (car left-re))
			  (this-entry (cadr left-re))
			  (right-re (partial-tree (cddr left-re) right-size)))
		  (let ((right-tree (car right-re))
				(remain-set (cdr right-re)))
			(cons (make-tree this-entry left-tree right-tree) remain-set)))))))
(define myset (list 1 3 7 8 19 20 41 44 56 66 73 82 89 99 102))
(display (list->tree myset))
